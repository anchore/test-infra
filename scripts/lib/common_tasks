#!/usr/bin/env bash

#####################################################
###   COMMON TASK COMMANDS - ALPHABETICAL ORDER   ###
#####################################################

# These functions are intended to be utilized as task commands invoked from the run_make_task script
# All tasks are generic between projects and should be reusable

kind_cluster_down() {
    local CLUSTER_NAME="${1:?'required parameter'}"

    kind delete cluster --name "${CLUSTER_NAME}"
}

kind_cluster_up() {
    local CLUSTER_NAME="${1:?'required parameter'}"
    local CLUSTER_CONFIG="${2:?'required parameter'}"
    local KUBERNETES_VERSION="${3:?'required parameter'}"

    local kind_node_image_tag="v${KUBERNETES_VERSION}"

    # if a kind cluster named e2e-testing is running export config, otherwise create a new cluster
    if ! kind get clusters | grep "${CLUSTER_NAME}"; then
        kind create cluster --name "${CLUSTER_NAME}" --config "${CLUSTER_CONFIG}" --image "kindest/node:${kind_node_image_tag}" --wait 60s
    fi
}

kind_load_image() {
    local CLUSTER_NAME="${1:?'required parameter'}"
    local IMAGE_NAME="${2:?'required parameter'}"

    if docker inspect "${IMAGE_NAME}" &> /dev/null; then
        print_colorized WARN "Using local image for e2e testing -- ${IMAGE_NAME}"
        kind load docker-image "${IMAGE_NAME}" --name "${CLUSTER_NAME}"
    else
        if [[ "${CI}" == true ]]; then
            # Test for required environment variables exported in CI jobs
            test "${DOCKER_PASS:?'required environment variable'}"
            test "${DOCKER_USER:?'required environment variable'}"

            echo "${DOCKER_PASS}" | docker login -u "${DOCKER_USER}" --password-stdin
            docker pull "${IMAGE_NAME}"
        else
            print_colorized ERROR "Please pull ${IMAGE_NAME} & re-run tests"
            exit 1
        fi
        print_colorized WARN "Using remote image for e2e testing -- ${IMAGE_NAME}"
        kind load docker-image "${IMAGE_NAME}" --name "${CLUSTER_NAME}"
    fi
}

get_local_e2e_image() {
    local COMMIT_SHA="${1:?'required parameter'}"
    local DEV_IMAGE_REPO="${2:?'required parameter'}"
    local GIT_TAG="${3:?'required parameter'}"
    local TEST_IMAGE_NAME="${4:?'required parameter'}"

    local e2e_image=''

    if docker inspect "${TEST_IMAGE_NAME}" &> /dev/null; then
        e2e_image="${TEST_IMAGE_NAME}"
    elif [[ "${GIT_TAG}" =~ ^v[0-9]+(\.[0-9]+)*$ ]]; then
        # get the latest rc git tag for this semver & use it for the image tag
        e2e_image="${DEV_IMAGE_REPO}:$(git describe --match "${GIT_TAG}-rc*" --tags --abbrev=0)"
    else
        e2e_image="${DEV_IMAGE_REPO}:${COMMIT_SHA}"
    fi

    echo "$e2e_image"
}

get_remote_e2e_image() {
    local GIT_BRANCH="${1:?'required parameter'}"
    local GIT_REPO="${2:?'required parameter'}"
    local GIT_TAG="${3:?'required parameter'}"
    local IMAGE_REPO="${4:?'required parameter'}"

    local e2e_image=''

    if DOCKER_CLI_EXPERIMENTAL=enabled docker manifest inspect "${IMAGE_REPO}:${GIT_TAG}" &> /dev/null; then
        e2e_image="${IMAGE_REPO}:${GIT_TAG}"
    elif DOCKER_CLI_EXPERIMENTAL=enabled docker manifest inspect "${IMAGE_REPO}:${GIT_BRANCH}" &> /dev/null; then
        e2e_image="${IMAGE_REPO}:${GIT_BRANCH}"
    else
        e2e_image="${IMAGE_REPO}:latest"
    fi

    echo "$e2e_image"
}

setup_e2e_tests() {
    local CLUSTER_NAME="${1:?'required parameter'}"
    local COMMIT_SHA="${2:?'required parameter'}"
    local DEV_IMAGE_REPO="${3:?'required parameter'}"
    local GIT_BRANCH="${4:?'required parameter'}"
    local GIT_REPO="${5:?'required parameter'}"
    local GIT_TAG="${6:?'required parameter'}"
    local TEST_IMAGE_NAME="${7:?'required parameter'}"

    local helm_deploy_name="${GIT_REPO}-e2e-${RANDOM:0:5}"
    local helm_install_log=''
    local anchore_image=''
    local anchore_ui_image=''

    kind export kubeconfig --name "${CLUSTER_NAME}"

    if [[ "${CI}" == true ]]; then
        # Test for required environment variables exported in CI jobs
        test "${DOCKER_PASS:?'required environment variable'}"
        test "${DOCKER_USER:?'required environment variable'}"

        if [[ "${GIT_REPO}" =~ ("enterprise"|"anchore-on-prem-ui") ]]; then
            test "${ANCHORE_LICENSE:?'required environment variable'}"
            # create anchore enterprise license secret using base64 encoded license file in $ANCHORE_LICENSE
            printf '%s' "${ANCHORE_LICENSE}" | base64 --decode > license.yaml
        fi

        # create k8s secret using $DOCKER_USER & $DOCKER_PASS and set as default imagePullCreds
        kubectl create secret docker-registry anchore-enterprise-pullcreds --docker-server=docker.io --docker-username="${DOCKER_USER}" --docker-password="${DOCKER_PASS}" --docker-email=anchoreci@anchore.com
        kubectl patch serviceaccount default --type=merge --patch '{"imagePullSecrets":[{"name": "anchore-enterprise-pullcreds"}]}'
    fi

    helm repo add stable https://kubernetes-charts.storage.googleapis.com

    # determine anchore-engine or anchore enterprise image
    if [[ "${GIT_REPO}" =~ ("enterprise"|"anchore-engine") ]]; then
        anchore_image="$(get_local_e2e_image "${COMMIT_SHA}" "${DEV_IMAGE_REPO}" "${GIT_TAG}" "${TEST_IMAGE_NAME}")"
        kind_load_image "${CLUSTER_NAME}" "${anchore_image}"

        if [[ "${GIT_REPO}" =~ "enterprise" ]]; then
            anchore_ui_image="$(get_remote_e2e_image "${GIT_BRANCH}" "${GIT_REPO}" "${GIT_TAG}" anchore/anchore-on-prem-ui-dev)"
            kind_load_image "${CLUSTER_NAME}" "${anchore_ui_image}"
        fi
    fi

    # determine anchore-on-prem-ui image
    if [[ "${GIT_REPO}" == "anchore-on-prem-ui" ]]; then
        anchore_image="$(get_remote_e2e_image "${GIT_BRANCH}" "${GIT_REPO}" "${GIT_TAG}" anchore/enterprise-dev)"
        kind_load_image "${CLUSTER_NAME}" "${anchore_image}"

        anchore_ui_image="$(get_local_e2e_image "${COMMIT_SHA}" "${DEV_IMAGE_REPO}" "${GIT_TAG}" "${TEST_IMAGE_NAME}")"
        kind_load_image "${CLUSTER_NAME}" "${anchore_ui_image}"
    fi

    if [[ "${GIT_REPO}" =~ ("enterprise"|"anchore-on-prem-ui") ]]; then
        if [[ -f license.yaml ]]; then
            kubectl create secret generic anchore-enterprise-license --from-file=license.yaml=license.yaml || true
        else
            print_colorized ERROR "ERROR - a valid anchore license.yaml file must exist in the project directory" && exit 1
        fi

        helm_install_log=$(helm install "${helm_deploy_name}" -f test/e2e/base-values.yaml --set anchoreEnterpriseGlobal.engineImage=${anchore_image} --set anchoreEnterpriseGlobal.image=${anchore_image} --set anchoreEnterpriseUi.image=${anchore_ui_image} stable/anchore-engine)
    else
        helm_install_log=$(helm install "${helm_deploy_name}" -f test/e2e/base-values.yaml --set anchoreEnterpriseGlobal.engineImage=${anchore_image} --set anchoreEnterpriseGlobal.image=${anchore_image} --set anchoreEnterpriseUi.image=${anchore_ui_image} stable/anchore-engine)
    fi
    echo "${helm_install_log}" | head -n6

    # Patch anchore-engine-api nodeport to the configured port thats mapped with kind to localhost:8228
    kubectl patch service "${helm_deploy_name}-anchore-engine-api" --type=json --patch '[{"op": "replace", "path": "/spec/ports/0/nodePort", "value":30028}]'
    if [[ "${GIT_REPO}" == "anchore-on-prem-ui" ]]; then
        # Patch anchore-enterprise-ui nodeport to the configured port thats mapped with kind to localhost:8080
        kubectl patch service "${helm_deploy_name}-anchore-enterprise-ui" --type=json --patch '[{"op": "replace", "path": "/spec/ports/0/nodePort", "value":30080}]'
    fi
}